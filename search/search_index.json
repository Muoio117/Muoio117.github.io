{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"About Me","text":""},{"location":"#about-me","title":"About Me","text":"<p>I am a self-taught game developer specializating in animation programming within the Unreal Engine. My formal training  is in my physics (M.S. Physics) and engineering (M.S. Mechanical &amp; Aerospace Engineering). If you're interested in my academic stuff, which is old and quite boring, you may check out my Google Scholar page.</p> <p>Prior to delving into game development, I leveraged my degree(s) to serve as an adjunct physics professor at multiple colleges: Orange Coast College, Southern California University of Health Sciences, Cypress College, and CSU Stanislaus. However, while pursuing my PhD in physics at UC Merced, I decided to completely change course --- to get out of academia and become a game developer. Was that a stupid decision? Maybe, but I certainly don't regret it. My bank account has a few regrets though.</p> <p>Since then, I have delved deep into animation-related topics in game development. While I'm certainly no animator, I tried my hand at animation and created the Unarmed Upright Standing (UUS) Animation Set, with the intent of ensuring all states blended well in Blendspace assets. Are the animations pretty? No, not at all. They look more stiff than I do when I run --- and I didn't know that was possible to achieve. But they meet the techincal requirements I aimed for at the start.</p> <p>Soon afterwards, I created the Animation Matching Suite plugin. The flagship feature was its ability to pose match and distance match Blendspace assets. (The initial release of the plugin was two engine versions prior to Epic's non-experimental introduction of native pose matching.) I never understood why Epic did not (and does not) support Blendspaces for distance matching, so I made the feature myself --- using my UUS Animation Set to test the Blendspace capabilities.</p> <p>After fiddling around so much with animations, I came to realize I truly dislike the process of animating. I'd rather just press some buttons to make things happen. Since I can't afford Maya, and since I dislike Blender, and since Cascadeur lacks many useful features, I decided to make the Anim Tools plugin (previously called MoCap Tools). It handles all the tedious and monotonous tasks I often found myself dealing with. It was also my first time attempting to use Slate. I discovered there is a reason \"Slate\" rhymes with \"hate.\"</p> <p>I also started a devlog. Due to health issues that came up near to when that project began, along with becoming a new father, I had to set that endeavor aside, at least for a time. But the general game development has not slowed.</p> <p>Anyway...now what am I up to? Well, I'm grinding. I keep learning new things in the hopes I can actually make a living doing what I love: animation programming.</p>"},{"location":"products/","title":"Index","text":""},{"location":"products/#about-these-tools","title":"About These Tools","text":"<p>Both plugins were born from real development needs and hundreds of hours working with animation systems in Unreal Engine. They're designed to eliminate tedious manual work and give you more control over your animation pipeline.</p> <p>All plugins support Unreal Engine 5.4+</p>"},{"location":"products/animationmatchingsuite/","title":"Animation Matching Suite","text":"<p>Documentation Not Migrated</p> <p>The documentation for the Animation Matching Suite (AMS) plugin has not yet been migrated from the original source.</p>"},{"location":"products/animtools/","title":"Anim Tools","text":"<p>Living Document</p> <p>This documentation is living, in that it will continue to get updated based on user feedback, with the goal being to continually increase clarity and coverage.</p>"},{"location":"products/animtools/#introduction","title":"Introduction","text":""},{"location":"products/animtools/#overview","title":"Overview","text":"<p>Blueprint and C++</p> <p>Knowledge of C++ is NOT required to leverage the capabilities of this plugin.</p> <p>The Anim Tools (AT) plugin --- previously named MoCap Tools (MCT) --- is a powerful framework for programmatically processing and modifying <code>UAnimSequence</code> assets within the Unreal Engine. It can be purchased on Epic's Fab Marketplace.</p> <p>Some of the key features are listed below.</p> <ul> <li>Bulk Animation Processing: Modify multiple AnimSequences at once.</li> <li>Custom Operations: Create user-defined Operations (<code>UATBaseOperation</code>) --- the actions applied to <code>UAnimSequence</code> assets --- in either C++ or Blueprint. This means users are not limited to whatever Operations are shipped with the plugin.</li> <li>Non-Destructive Workflow: Preview changes before applying them and choose whether to overwrite existing assets or generate new ones.</li> <li>Per-Animation Property Control: Configure Operation properties differently for each AnimSequence.</li> </ul>"},{"location":"products/animtools/#requirements","title":"Requirements","text":"<p>The Anim Tools plugin is supported for Unreal Engine 5.6+. (The predecessor, Mocap Tools, which is the original form of this plugin, is supported for engine versions 5.4 and 5.5, but no further updates will be provided for MoCap Tools.)</p>"},{"location":"products/animtools/#installation","title":"Installation","text":"<p>To install the plugin, either bring it into the project via the Epic Launcher or drag and drop the plugin into the project's <code>Plugins</code> folder. Once installed, enable the Anim Tools plugin within the Editor by selecting to <code>Edit</code>-&gt;<code>Plugins</code>. In the <code>Plugins</code> window, type <code>Anim Tools</code>, then click the checkbox and follow the prompt to restart the Editor.</p> <p> </p>"},{"location":"products/animtools/#quick-start-guide","title":"Quick-Start Guide","text":"<ol> <li> <p>Create a Database:      Right-click in the Content Browser, select Anim Tools, then click on ATDatabase. Name the asset appropriately, then double-click on it to open it. </p> <p> </p> <p>Each database will hold the AnimSequences to be acted upon and the Operations to perform those actions.</p> </li> <li> <p>Populate the Animation List:      Add <code>UAnimSequence</code> assets to the Animation List by either performing a drag-and-drop or by pressing the Add button.</p> <p> </p> </li> <li> <p>Set the Configuration:      In the Configuration tab, set the output details, mesh orientation, and bone references. The latter two are in reference to the skeleton of the <code>UAnimSequence</code> assets already placed within the Animation List.</p> <p></p> </li> <li> <p>Add Operations:      Add Operation assets to the Operation List tab by selecting from the default Operations shipped with the Anim Tools plugin. (The process for creating a custom Operation --- a child of <code>UATBaseOperation</code>--- will be shown later.) Edit the details on either a bulk or per-animation basis.</p> <p></p> </li> <li> <p>Preview the Edited Animations:      In the toolbar at the top of the viewport, switch from Original to Edited to preview what the output animations would look like. (This is non-destructive, of course.) To have Animations displayed properly, ensure <code>bEnableRootMotion = true</code> and <code>bForceRootLock = true</code> in all corresponding Anim Sequences.     </p> </li> <li> <p>Press Apply:     If everything looks as desired, press Apply to finalize the changes.</p> <p></p> </li> </ol>"},{"location":"products/animtools/#core-concepts","title":"Core Concepts","text":""},{"location":"products/animtools/#database","title":"Database","text":"<p> The AT Database (<code>UATDatabase</code>) is the central asset in Anim Tools. It organizes everything needed to batch-process animations: the list of animations to modify, the list of Operations to apply to those animations, and general configurable settings.</p> <p>To create one, right-click on the Content Browser, hover over Anim Tools, then select AT Database. From left to right, the tabs shown are the Animation List, Viewport, Configuration, and Operation List List. (Note: by default, the Configuration and Operation List tabs will share the same space.)</p> <p></p> <p>The Animation List tab will hold all the Anim Sequence (<code>UAnimSequence</code>) assets that are to be modified. They can be added by pressing the Add button or by doing a drag-and-drop. Once an Anim Sequence is placed into the list, the underlying skeleton (<code>USkeleton</code>) of the Database will be automatically set, and any functionality requiring a skeleton will read from that set skeleton. For example, any further Anim Sequences added to the list must be of the same skeleton as the currently existing Anim Sequences within the list.</p> <p>Enable Root Motion</p> <p>To have Animations displayed properly in the viewport, ensure <code>bEnableRootMotion = true</code> and <code>bForceRootLock = true</code> in all corresponding Anim Sequences.</p> <p>The Viewport tab is, unsurprisingly, the preview port displaying currently selected Anim Sequences. Not all Anim Sequences within the Animation List will be displayed in the Viewport; only selected Anim Sequences within the list will be displayed. (To select multiple assets at once, use either <code>Shift</code> <code>+</code> <code>Click</code> or <code>Ctrl</code> <code>+</code> <code>Click</code>.)</p> <p>The Configuration tab contains general settings. The Output section details whether the modified Anim Sequences should overwrite existing assets (in place) or write to newly created Anim Sequences within a user-specified directory. The Mesh Direction section requires the user to specify two axes. </p> <ol> <li>Mesh Forward Axis: the axis of the root along which the mesh, in its reference pose, faces forward. (For the UE5 Manny, for example, this is the <code>+Y</code> axis.)</li> <li>Mesh Up Axis: the axis of the root, in the reference pose, pointing vertically upward along the mesh. (For the UE5 Manny, for example, this is the <code>+Z</code> axis.)</li> </ol> <p>The Bone section should be populated with the appropriate Root and Hips bones, which would, for example, be the <code>root</code> and <code>pelvis</code> bones in the UE5 Manny. NOTE: The Mesh Direction and Bone sections may not be absolutely necessary; however, they are currently used in some of the Operations shipped with Anim Tools, so they must be filled out.</p> <p>The Operation List tab will hold all the Operations (<code>UATBaseOperation</code>) to be applied to the Anim Sequences. Operations are the mechanism by which the Anim Sequences are modified. They can be created in either C++ or Blueprint, and they are applied in sequential order (i.e. in top-down order). To add Operations, press the Add button or drag and drop them into the window. Reordering can be performed by a simple click-and-drag.</p>"},{"location":"products/animtools/#animation","title":"Animation","text":"<p>When an Anim Sequence (<code>UAnimSequence</code>) asset is added to the Database, Anim Tools doesn't work directly with the Anim Sequence --- not at first, at least. Instead, it creates a <code>UATAnimation</code> \"wrapper,\" which essentially acts as a sort of \"working copy\" that does the below.</p> <ol> <li>Reads data from the original <code>UAnimSequence</code> to populate its own member variables.</li> <li>Stores that data in a format optimized for manipulation.</li> <li>Tracks all changes made during processing (via Operations).</li> <li>Writes the modified data back to the original <code>UAnimSequence</code> (or a copy) to create the final output.</li> </ol> <p>This wrapper is what makes the non-destructive workflow possible --- the original Anim Sequences remain untouched unless the option to overwrite them is explicitly chosen.</p> <p>The Animation (<code>UATAnimation</code>) is the class that will be interacted with by the user within an Operation. There are many functions built into the class to facilitate easy and intuitive modification of the data. Functions like the simple <code>GetBonePoseByName</code> and <code>SetBonePoseByName</code> are two that will likely get the most use, but, as can be seen in the picture to the right, there are many default functions --- and more can be added upon reasonable request.</p>"},{"location":"products/animtools/#operation","title":"Operation","text":"<p>An Operation is a reusable, configurable action applied within the Database to modify Anim Sequence assets --- via modification to the wrapper <code>UATAnimation</code>. All Operations inherit from the base class <code>UATBaseOperation</code> and can be created in either C++ or Blueprint. </p> <p>In C++, the below is an example of the basic setup with the three virtual functions to override. <pre><code>UCLASS(Blueprintable, DisplayName = \"Example Operation\")\nclass UATExampleOperation : public UATBaseOperation\n{\n    GENERATED_BODY()\n\npublic:\n\n    UATExampleOperation(); // overwrite the Description member variable here\n\n    //=== Base Operation ===\n    virtual void AnalyzeAnimationSet_Implementation(const TArray&lt;UATAnimation*&gt;&amp; Animations, const UATConfigurationTab* Configuration);      \n    virtual void Execute_Implementation(UATAnimation* Animation, const UATConfigurationTab* Configuration, const int32 AnimIndex) override;\n    virtual void ConfigureAutoBindings_Implementation() override;\n    //======================\n\n    // place member functions and variables here\n}\n</code></pre>  In Blueprint, an Operation is created by right-clicking on the Content Browser, hovering over Anim Tools, then selecting AT Operation. As with the C++ variant, there are three overridable functions: <code>AnalyzeAnimationSet</code>, <code>Execute</code>, and <code>ConfigureAutoBindings</code>. The first two are Events in Blueprint, and the third is a function to be overridden in the usual way.</p> <p>Let us take a moment to explain these three functions.</p>"},{"location":"products/animtools/#main-functions","title":"Main Functions","text":""},{"location":"products/animtools/#analyze-animation-set","title":"Analyze Animation Set","text":"<p>This optional function is called once before any Animations (<code>UATAnimation</code>) are modified. Notice the three properties: <code>Animations</code> and <code>Configuration</code>.</p> <ul> <li>The <code>Animations</code> is a <code>const</code> array of Animations (i.e. <code>TArray&lt;UATAnimation*&gt;</code>). The <code>const</code> means the Animations will not be modified, but they can be read from.</li> <li>The <code>Configuration</code> is the pointer to the Configuration tab, allowing users to conveniently access data set there.</li> </ul> <p>Since the <code>AnalyzeAnimationSet</code> function receives the entire list of Animation to be processed, it grants users the freedom to examine all Animations as a group to, for example, extract global statistics (i.e. averages, min/max, etc), validate the Animations meet certain criteria, store shared data all Animations will need, etc. It is called before <code>Execute</code>, as shown below.</p> <p><pre><code>    User clicks \"Apply\"\n        \u2193\n    AnalyzeAnimationSet (runs once, sees all Animations)\n        \u2193\n    Execute (runs for Animation 1)\n        \u2193\n    Execute (runs for Animation 2)\n        \u2193\n    Execute (runs for Animation 3)\n        \u2193\n    ... and so on\n</code></pre> If no such data are needed for the Operation's subsequent <code>Execute</code> function, the <code>AnalyzeAnimationSet</code> function can be left alone; it does not need to be overridden. </p> <p>To see an example of how <code>AnalyzeAnimationSet</code> is used in practice, look at the code for the <code>Retime Anims for BlendSpace</code> (i.e. <code>UATRetimeOperation</code>) Operation shipped with Anim Tools.</p>"},{"location":"products/animtools/#execute","title":"Execute","text":"<p><code>Execute</code> is the heart of the Operation. It is called once per Animation and is where the user modifies the Animation data: bone, curve, sync marker, etc. data. These modifications will then be taken and baked into Anim Sequence assets.</p> <p>Notice the three properties: <code>Animation</code>, <code>Configuration</code>, and <code>AnimIndex</code>. </p> <ul> <li>The <code>Animation</code> is the current Animation (<code>UATAnimation*</code>) being modified. All adjustments made to this Animation will carry over to the Anim Sequence assets.</li> <li>The <code>Configuration</code> is the pointer to the Configuration tab, allowing users to access data set there.</li> <li>The <code>AnimIndex</code> corresponds to the index of the current Animation within the Animation List tab (which is zero-based, of course).</li> </ul> <p></p>"},{"location":"products/animtools/#configure-auto-bindings","title":"Configure Auto-Bindings","text":"<p>The <code>ConfigureAutoBindings</code> is an optional override that allows the user to establish automatic bindings placed upon class properties when those class properties are per-Animation editable. (More on per-Animation editability is discussed in a later section.) To make use of <code>ConfigureAutoBindings</code>, the user must call one or both of the following functions: <code>BindFunctionToProperty</code> and <code>BindPropertyToProperty</code>. These functions do the work of facilitating the bindings. </p> <p>For example, in the <code>Trim Operation</code> (<code>UATTrimOperation</code>) class, the <code>TrimPoint</code> member variable, which is of type <code>int32</code>, should only be allowed to have values between <code>0</code> and <code>NumOfAnimKeys - 1</code>; otherwise, <code>TrimPoint</code> will be beyond the bounds of the Animation. (An Animation cannot be trimmed at a point beyond its boundaries.) To ensure the UI reflects this boundary, the <code>ConfigureAutoBindings</code> function is used, and the <code>BindFunctionToProperty</code> function is called twice to ensure the <code>GetTrimPointMin</code> function and <code>GetTrimPointMax</code> function are both bound to the <code>TrimPoint</code> property. In C++, this would looks as shown below. <pre><code>void UATTrimOperation::ConfigureAutoBindings_Implementation()\n{\n    BindFunctionToProperty(GET_MEMBER_NAME_CHECKED(UATTrimOperation, TrimPoint), EATPropertyBindingType::MinValue, FName(TEXT(\"GetTrimPointMin\")));\n    BindFunctionToProperty(GET_MEMBER_NAME_CHECKED(UATTrimOperation, TrimPoint), EATPropertyBindingType::MaxValue, FName(TEXT(\"GetTrimPointMax\")));\n}\n</code></pre> The equivalent in Blueprint looks as shown. </p> <p>The result in the Editor is shown in the below <code>gif</code>. The two bound functions can be seen in a widget to the right of the <code>TrimPoint</code> property. Those functions are the same <code>GetTrimPointMin</code> and <code>GetTrimPointMax</code> functions set above. Their effect in this example is disallowing the user to set values beyond the Animation bounds.</p> <p></p> <p>So far, only two binding types of have been shown: min value and max value. However, there are four available, depending on the property type being bound to.</p> <ol> <li>Is Enabled: Controls whether a per-Animation editable property is enabled for editing in the Editor.</li> <li>Min Value:  Sets the minimum allowed value.</li> <li>Max Value:  Set the maximum allowed value.</li> <li>Should Filter:  Controls whether an asset should be filtered in a picker. (This is only valid for children of <code>UObject</code>.)</li> </ol> <p></p> <p>None need to be set via <code>ConfigureAutoBindings</code>. The widget allows bindings to be added manually after an Operation has been added to the Database. However, constantly needing to add bindings each time the same Operation is added to a new Database can be bothersome; hence, the benefit of <code>ConfigureAutoBindings</code>.</p> <p>Careful With Property Access</p> <p>Functions called by <code>BindFunctionToProperty</code> and <code>BindPropertyToProperty</code> must use special getters to access member variables.</p> <p>Regarding the functions called within the <code>BindFunctionToProperty</code> and <code>BindPropertyToProperty</code> functions, if those functions --- such as <code>GetTrimPointMin</code> and <code>GetTrimPointMax</code> in the above example --- access member variables, some special care must be taken. Rather than accessing a member variable directly, as would normally be the case, member variables must be accessed using special getters. These getters are in the <code>Operation Bindings</code> subcategory within the <code>Anim Tools</code> category (and can rightly be accessed only within an Operation). For a C++ example demonstrating how one of these getters is used, refer to <code>GetIntervalMin</code> function of the <code>Align Anim with Axis</code> (<code>UATAlignAnimWithAxisOperation</code>) class.</p> <p>All that said, it should be noted that <code>ConfigureAutoBindings</code> is optional, and bindings in general are optional.</p>"},{"location":"products/animtools/#per-animation-control","title":"Per-Animation Control","text":"<p>Custom Metadata</p> <p>In C++, the custom <code>AllowPerAnimEdits</code> and <code>PerAnimEditCondition</code> meta specifiers are used to trigger specific per-Animation control.</p> <p>Operations support properties having per-Animation editability, meaning properties can have different values for each Animation. This grants fine-grained control so the user can tailor the select Operation to act in a relevant way on each Animation.</p> <p>Not All Types Supported</p> <p>Not all property types are supported for per-Animation editability. Currently, the following types are supported: <code>bool</code>, <code>int32</code>, <code>float</code>, <code>double</code>, <code>uint8</code>, <code>int64</code>, <code>FIntPoint</code>, <code>FVector2D</code>, <code>FVector</code>, <code>FVector4</code>, <code>FRotator</code>, and <code>UObject</code>.</p> <p>For a Blueprint property to be eligible for per-Animation editability, it must be <code>public</code> and marked as <code>bInstanceEditable = true</code>; similarly, for a C++ property, it must be <code>public</code> or <code>protected</code>, marked as a <code>UPROPERTY</code>, specified as <code>EditAnywhere</code>, and given the custom metadata <code>AllowPerAnimEdits</code>. (In the case of Blueprint, for the property to appear at all in the Database's instance of the Operation, the aforementioned criteria must be met.)</p> <p></p> <p>The result, of course, is the ability to set different values of the property for each Animation.</p> <p></p>"},{"location":"products/animtools/#edit-condition","title":"Edit Condition","text":"<p>This freedom comes with another thing to consider, at least in the case of C++ implementation. That is, what about the <code>EditCondition</code> meta property? When a property is per-Animation editable, using the standard <code>EditCondition</code> will apply a blanket effect to all per-Animation editable properties displayed in the Per-Animation Settings grid.   Often, however, we may desire the state of one (or more) per-Animation property to affect another per-Animation property in a granular way. Hence, the <code>PerAnimEditCondition</code> is introduced. For example, the below code snippet is taken from the <code>Blend Anim Ends</code> Operation (i.e. <code>UATBlendAnimEndsOperation</code>).</p> <p><pre><code>    /** The generic target for blending.\n     *  - Self: this Animation.\n     *  - Other: a different select AnimSequence. */\n    UPROPERTY(EditAnywhere, Category = \"Blend\", Meta = (AllowPerAnimEdits))\n    EATBlendTarget GenericBlendTarget {EATBlendTarget::Self};\n\n    /** The AnimSequence to blend to. (This, of course, is only relevant if BlendTarget = Other.) */\n    UPROPERTY(EditAnywhere, Category = \"Blend\", Meta = (AllowPerAnimEdits, PerAnimEditCondition = \"GenericBlendTarget == EATBlendTarget::Other\"))\n    TObjectPtr&lt;UAnimSequence&gt; AnimSequenceBlendTarget {nullptr};\n</code></pre> The effect of the <code>PerAnimEditCondition</code> is shown the corresponding gif.</p> <p></p>"},{"location":"products/animtools/#bindings","title":"Bindings","text":"<p>Another method of controlling the behavior of per-Animation editable properties is through bindings. As shown to the right, when the per-Animation toggle is enabled, a dropdown can be clicked to reveal between one and three bindings options, depending on the property type. These affect the corresponding property as the binding name implies. In the pictured example, <code>IsEnabled</code>, <code>MinValue</code>, and <code>MaxValue</code> are available for the property, and each binding can be manually set to another member variable or function of the Operation class. (For auto-bindings, refer to the Configure Auto-Bindings section above.)</p> <p>Conflicts</p> <p>Do not use <code>PerAnimEditCondition</code> together with the <code>IsEnabled</code> binding on the same property, as it will likely cause conflicts.</p> <p>The <code>IsEnabled</code> binding effectively does what the <code>PerAnimEditCondition</code> can do: it determines when a property is enabled (and therefore editable). Avoid using both on the same property. Since <code>IsEnabled</code> is obviously a <code>bool</code>, it can be bound either a <code>bool</code> class member variable or a pure function that returns <code>bool</code>.</p> <p>The <code>MinValue</code> and <code>MaxValue</code> bindings dictate, as the names imply, the minimum and maximum values the corresponding property is allowed to take in the Per-Animation Settings grid. They can only be bound to member variables of the same type as the property in question or a pure function returning the same type as that property. For example, if <code>MinValue</code> and <code>MaxValue</code> are applied to a <code>float</code> property, only <code>float</code> properties or pure functions returning a <code>float</code> can be used as bindings.</p>"},{"location":"products/animtools/#utility-libraries","title":"Utility Libraries","text":"<p>Anim Tools includes utility libaries to accelerate the development of user-created Operations. The main libraries are the Math Library (<code>UATMathLibrary</code>) and Animation Library (<code>UATAnimLibrary</code>). These two libraries hold many useful functions intended to complement the default functions of Unreal, with the express intent of Animation modification. Many of the functions within the libraries have been used within the Operations that ship with Anim Tools.</p>"},{"location":"products/animtools/#included-operations","title":"Included Operations","text":"<p>As with the previous MoCap Tools (MCT) plugin, significant prebuilt and immediately applicable functionality is available within Anim Tools via the ready-to-use Operations.</p>"},{"location":"products/animtools/#align-anim-with-axis","title":"Align Anim with Axis","text":"<p>The <code>Align Anim with Axis</code> Operation (i.e. <code>UATAlignAnimWithAxisOperation</code>) aligns the Animation (via the hips bone) and/or the root trajectory along a designated axis. A vector between the first and last key of the Animation (or selected interval) is created, and that vector is then rotated to align with the given axis, bringing the entire Animation and/or root trajectory with it. This functionality is primarily useful for animations meant to be straight-line movement, such as cut clips for <code>F-000</code>, <code>R-090</code>, <code>L-045</code>, etc.</p>"},{"location":"products/animtools/#blend-anim-ends","title":"Blend Anim Ends","text":"<p>The <code>Blend Anim Ends</code> Operation (i.e. <code>UATBlendAnimEndsOperation</code>) blends Animation ends together using select inertialization methods in the Local Space of the bones; that is, the Operation can ensure the first/last frame of an Animation matches </p> <ol> <li>the last/first frame in the same Animation,</li> <li>the first frame in another Animation, or</li> <li>the last frame in another Animation.</li> </ol> <p>Thanks goes to Daniel Holden for inspiring this Operation. Be sure to check out his article for details.</p>"},{"location":"products/animtools/#constrain-bones","title":"Constrain Bones","text":"<p>The <code>Constrain Bones</code> Operation (i.e. <code>UATConstrainBonesOperation</code>) allows users to constrain select skeletal bones via:</p> <ol> <li>constraining each to another bone or set of bones, or</li> <li>constraining each via manual input.</li> </ol> <p>This Operation can be used to, for example, constrain the root bone --- the simulation bone --- to the weighted-averaged ground-projected position of the hips, spine, and feet bones of motion capture data.</p>"},{"location":"products/animtools/#constrain-ik","title":"Constrain IK","text":"<p>The <code>Constrain IK</code> Operation (i.e. <code>UATConstrainIKOperation</code>) is meant as a \"quick fix\" Operation to constrain IK bones to FK bones for skeletons that follow the Unreal standard naming convention for IK and FK bones. If this Operation does not work as desired, please refer to the Constrain Bones Operation, which is more detailed and complete and will allow the constraint any bone, including IK, to any other bone.</p>"},{"location":"products/animtools/#copy-motion-experimental","title":"Copy Motion (Experimental)","text":"<p>Solid Application of Copy Motion?</p> <p>Does anyone know how to apply the Copy Motion anim node in a way to produce the results Epic showed in their demonstration? If so, please let me know, that way I can update this Operation.</p> <p>The <code>Copy Motion</code> Operation (i.e. <code>UATCopyMotionOperation</code>) is inspired by Epic's experimental Copy Motion anim node (<code>FAnimNode_CopyMotion</code>), described in this article. The Operation is, of course, an offline version of the <code>FAnimNode_CopyMotion</code> class provided by Epic, but the core features are present. Essentially, the Operation, as with the anim node, \"generates an additive transform for a specific bone based on some input poses, optionally in the space of another bone,\" and then allows that additive transform (internally called the <code>TransformOffset</code>) to be scaled and reoriented prior to its application. </p> <p>This Operation is currently experimental because the output is not of the same level of quality as what Epic showed in their demonstration.</p>"},{"location":"products/animtools/#curve-to-root-motion-experimental","title":"Curve to Root Motion (Experimental)","text":"<p>The <code>Curve to Root Motion</code> Operation (i.e. <code>UATCurveToRootMotionOperation</code>) extracts distance or speed curve data from an Animation's float curves and generates root motion. The above gif demonstrates the results when the Operation is applied to the Stop-state Animations from Gideon (the character from Paragon). </p>"},{"location":"products/animtools/#generate-root-bone-curves","title":"Generate Root Bone Curves","text":"<p>The <code>Generate Root Bone Curves</code> Operation (i.e. <code>UATGenerateRootCurvesOperation</code>) generates specified float curves for the root bone of the Animations, placing a curve key at every anim key. The exact curves that can be generated are distance, speed, velocity, acceleration, jerk, and locomotion angle. All curves, aside from the distance curve, are generated relative to pseudo-Component space --- the space the simulation object (i.e. Capsule) would dictate at runtime. (This is done so curves representing vector-related values \"point\" in the \"intuitive\" direction and can be used as such as runtime.) This, of course, requires <code>MeshForwardAxis</code> and <code>MeshUpAxix</code> to be correctly populated in the Configuration tab.</p> <p>The distance curve is created following Paragon's convention, as shown by Laurent Delayen, and is therefore monotonic increasing. There are three options: <code>FromMarker</code>, <code>ToMarker</code>, <code>ToAndFromMarker</code>.</p> <ol> <li><code>FromMarker</code> would be used for a Start-state Animation, where the character is moving away from some point in the world.</li> <li><code>ToMarker</code> would be used for a Stop-state Animation, where the character is moving toward some point in the world.</li> <li><code>ToAndFromMarker</code> would be used for a Pivot-state Animation, where the characater is changing direction --- he is moving toward a point and then away from it.</li> </ol> <p>For derivative curves, there are two options for generation: central finite-difference and Savitzky-Golay. Each option has its strength. Choose what works best.</p>"},{"location":"products/animtools/#remove-root-offset","title":"Remove Root Offset","text":"<p>The <code>Remove Root Offset</code> Operation (i.e. <code>UATRemoveRootOffsetOperation</code>) removes the root bone's offset relative to the root bone's transform at the specified anim key. That is, if <code>0</code> is the selected anim key, the entire Animation will be shifted such that the start of the Animation is at the World origin, for example.</p>"},{"location":"products/animtools/#retime-anims-for-blendspace","title":"Retime Anims for Blendspace","text":"<p>The <code>Retime Anims for Blendspace</code> Operation (i.e. <code>UATRetimeOperation</code>) prepares locomotion-specific Animations to blend within Blendspaces. However, since the algorithm is not magical, the Animations must adhere to the below criteria; otherwise, all sorts of unaesthetic things will likely result.</p> <ol> <li>Sync markers corresponding to foot steps MUST be present on ALL Animations.</li> <li>Animations must have the same number of foot steps (and therefore sync markers) for each foot. (The number of steps of the right foot must be the same across all selected Animations, and the number of steps of the left foot must be the same across all Animations.)</li> <li>The locomotion gait must be the same; that is, the Animations must be all walking, or all jogging, etc.</li> <li>The animations must share the same locomotion state: start, stop, loop, pivot, etc. </li> </ol> <p>Internally, the Operation creates a time mapping from the original sync marker positions within the Animations to the averaged target positions, then resamples every anim key by interpolating from the original Animation at the mapped source time. To account for the issue of the root bone's trajectory stretching and squeezing in response to the retiming, there is the <code>Retime And Adjust Root And Stride</code> option that readjusts the root trajectory to enforce that it maintains its original \"character,\" after which stride warping is applied to account for the delta.</p>"},{"location":"products/animtools/#smooth-bone-trajectory","title":"Smooth Bone Trajectory","text":"<p>The <code>Smooth Bone Trajectory</code> Operation (i.e. <code>UATSmoothBoneTrajectoryOperation</code>) smooths a bone's trajectory using one of four methods: <code>Linear</code>, <code>Moving Average</code>, <code>Savitzky-Golay</code>, or <code>Adaptive Spline</code>. Since three of the four options create edge artifacts, mitigation measures are made available via the <code>Pre-Extrapolation</code> and <code>Post-Extrapolation</code> variables, which can be set as <code>Constant</code>, <code>Linear</code>, <code>Quadratic</code>, <code>Looping</code>, or <code>Periodic</code> --- where <code>Periodic</code> is highly experimental.</p>"},{"location":"products/animtools/#trim-animations","title":"Trim Animations","text":"<p>The <code>Trim Animations</code> Operation (i.e. <code>UATTrimOperation</code>) trims Animations at one or two designated anim keys. If a single anim key is selected, the Animation can either be trimmed before or after the designated anim key, preserving the selected anim key --- i.e. not trimming the selected key. If two keys are selected, the portion between the two keys, inclusively, is preserved and the borders are removed.</p>"},{"location":"products/animtools/#experimental-features","title":"Experimental Features","text":""},{"location":"products/animtools/#control-rig","title":"Control Rig","text":"<p>The <code>ApplyControlRig</code> node accepts any Control Rig class and applies is directly to every frame of the input Animation (<code>UATAnimation</code>). This node was created upon special request from a friend. Though it seems to function well, it does not currently support input parameters. </p> <p>Potential updates may include functionality to pass in parameters via pins. Additionally, if possible, a per-key version of the node could be created --- or could replace the current version. Much of this depends on user feedback.</p>"},{"location":"products/animtools/#anim-nodes","title":"Anim Nodes","text":"<p>Set the Skeletal Mesh</p> <p>In order for the internal workings of the <code>Anim Node</code> wrapper to work, a skeletal mesh must be applied to the Anim Sequence assets be used.</p> <p></p> <p>The Anim Tools <code>Anim Node</code> is highly experimental. Due to how real anim nodes work within the Anim Instance and Anim Graph, it is doubtful the full functionality of anim nodes can ever be brought into Anim Tools, particularly for anim nodes that depend on World time and other information. Currently, the anim nodes that seem to function are those that don't depend on information that would otherwise be fed into it via the Anim Graph. In my experience, simple IK nodes and layering nodes seem to work fine. </p> <p>Feedback is appreciated on this experimental feature.</p>"},{"location":"products/animtools/#faq","title":"F.A.Q.","text":"<ol> <li>How is Anim Tools different from a simple Anim Modifier?<ul> <li>A non-destructive workflow is permitted.</li> <li>Multiple animation assets can be analyzed at once, allowing for the extraction of statistical data.</li> <li>Modifications can be previewed in the viewport.</li> <li>Select Anim Nodes can be applied via the experimental Anim Node wrapper node.</li> <li>Control Rig can be directly applied via the experimental Control Rig wrapper node.</li> <li>Extensive function libraries and function built into the Animation (<code>UATAnimation</code>) class streamline the workflow.</li> </ul> </li> </ol>"}]}